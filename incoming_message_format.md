# Incoming Message Format : HTTP Request

## Kafka Connect Architecture

### low level serialization
Kafka, at the low level, handle transformation of an Object in a language (Java, Python, etc...) from the Kafka client to bytes via _serializers_, which are transmitted on the network to the Kafka Broker.

But when the message is transmitted, both ends are linked to the message format.

### high-level serialization and format independance with Kafka Connect

Kafka Connect try to solve this coupling problem, with `Converters`, which internally owns a configured low level serializer.

Converters are configured per connector instance.

Converters transform a `byte array`, into a java `Object`, linked to a Schema,describing the object structure (`org.apache.kafka.connect.data.SchemaAndValue`).
Most of converters, like `JSONConverter`, `JSONSchemaConverter`, `AvroConverter`, and `ProtobufConverter`, but not `StringConverter`,
convert internally their native format (respecctively `JSON`, `JSONSchema`, `Avro`, and `Protobuf`),
to a `Struct` instance, representing a structured message, via some internal helpers (`JsonSchemaData`,`AvroData`,`ProtobufData`).

### What impact of this Kafka Connect design for the Http Sink Connector ?

The HTTP Sink Connector, support `structured messages`, coming from different formats (JSON Schema, Avro, and Protobuf),
but tests have been done only on JSON Schema. This is the main use case.
Due to some format-related tricks which cannot be hidden by the kafka conncet strategy (for example, supported types and so on..),
Avro and Protobuf should work as incoming format, but without guarantee.

The HTTP Sink Connector, support also String messages, but not as the main use case.

## HTTP Request incoming Format

### fields

#### Request Fields

- `url`
- `method`
- headers :
  - `X-Request-ID` : is useful to add to track the request. can be generated by the sink connector via the `generate.missing.request.id` setting set to `true`
  - `X-Correlation-ID` : is useful to add to track multiple interactions linked together. can be generated by the sink connector via the `generate.missing.correlation.id` setting set to `true`
- `bodyType` (valid values are `STRING`,`BYTE_ARRAY` and `MULTIPART`, but only `STRING` is supported)
- `bodyAsString`
- `bodyAsByteArray` (not yet supported)
- `bodyAsMultipart` (not yet supported)

### Struct format

The `HttpRequest` class represents the incoming message.

Here is the source code which define the Struct format, base source for JSON Schema/Avro/Protobuf solutions : 

```java
    public Struct toStruct() {
        return new Struct(SCHEMA)
        .put(URL, url)
        .put(HEADERS, headers)
        .put(METHOD, method)
        .put(BODY_TYPE, bodyType.name())
        .put(BODY_AS_STRING, bodyAsString)
        .put(BODY_AS_BYTE_ARRAY, bodyAsByteArray)
        .put(BODY_AS_MULTIPART, bodyAsMultipart);
```

### JSON Schema format

[HTTP Request JSON Schema Format](src/test/resources/http-request.json)

